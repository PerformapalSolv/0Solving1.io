<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>并查集Union-Find-algorithm | /0Solving1/</title><meta name="author" content="LYT"><meta name="copyright" content="LYT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当然！并查集（Union-Find）是一种用于处理动态连通性问题的数据结构。它通常用来处理像网络连通性、集合合并等问题。并查集操作高效，尤其适用于需要频繁进行合并和查询的情景，具有接近常数时间复杂度。 以下是对并查集的详细解释，包括它的基本概念、实现步骤，以及C++代码示例。 1.并查集的基本概念并查集的主要功能有两个：  查找（Find）：确定某个元素属于哪个集合。 合并（Union）：将两个元">
<meta property="og:type" content="article">
<meta property="og:title" content="并查集Union-Find-algorithm">
<meta property="og:url" content="https://0solving1.cn/2024/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86Union-Find-algorithm/index.html">
<meta property="og:site_name" content="&#x2F;0Solving1&#x2F;">
<meta property="og:description" content="当然！并查集（Union-Find）是一种用于处理动态连通性问题的数据结构。它通常用来处理像网络连通性、集合合并等问题。并查集操作高效，尤其适用于需要频繁进行合并和查询的情景，具有接近常数时间复杂度。 以下是对并查集的详细解释，包括它的基本概念、实现步骤，以及C++代码示例。 1.并查集的基本概念并查集的主要功能有两个：  查找（Find）：确定某个元素属于哪个集合。 合并（Union）：将两个元">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg">
<meta property="article:published_time" content="2024-11-26T13:44:14.000Z">
<meta property="article:modified_time" content="2024-11-27T08:02:21.024Z">
<meta property="article:author" content="LYT">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="DataStruct">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://0solving1.cn/2024/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86Union-Find-algorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '并查集Union-Find-algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i: 0"></div><div class="iron-coil" style="--i: 1"></div><div class="iron-coil" style="--i: 2"></div><div class="iron-coil" style="--i: 3"></div><div class="iron-coil" style="--i: 4"></div><div class="iron-coil" style="--i: 5"></div><div class="iron-coil" style="--i: 6"></div><div class="iron-coil" style="--i: 7"></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/baiyingcheng.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2024/11/25/wTHFUo8B4IqvzL2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">/0Solving1/</span></a><a class="nav-page-title" href="/"><span class="site-name">并查集Union-Find-algorithm</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">并查集Union-Find-algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-26T13:44:14.000Z" title="发表于 2024-11-26 21:44:14">2024-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-27T08:02:21.024Z" title="更新于 2024-11-27 16:02:21">2024-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DataStruct-Algorithm/">DataStruct-Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>当然！并查集（Union-Find）是一种用于处理<strong>动态连通性</strong>问题的数据结构。它通常用来处理像网络连通性、集合合并等问题。并查集操作高效，尤其适用于需要频繁进行合并和查询的情景，具有接近常数时间复杂度。</p>
<p>以下是对并查集的详细解释，包括它的基本概念、实现步骤，以及C++代码示例。</p>
<h3 id="1-并查集的基本概念"><a href="#1-并查集的基本概念" class="headerlink" title="1.并查集的基本概念"></a>1.并查集的基本概念</h3><p>并查集的主要功能有两个：</p>
<ol>
<li><strong>查找（Find）</strong>：确定某个元素属于哪个集合。</li>
<li><strong>合并（Union）</strong>：将两个元素所在的集合合并为一个集合。</li>
</ol>
<p>并查集通常通过树结构实现，每个元素都指向它的父节点，通过这种方式可以追溯到树的根节点。</p>
<ul>
<li><strong>父节点（Parent）</strong>：并查集中每个元素有一个指向其父节点的指针。</li>
<li><strong>根节点（Root）</strong>：在并查集中，一个集合可以看作是一棵树的形式，根节点是整个树的代表元素。</li>
</ul>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><p>为了提高并查集操作的效率，通常会使用以下两个重要的优化技巧：</p>
<ol>
<li><strong>路径压缩（Path Compression）</strong>：在执行查找操作时，将访问的节点直接连接到根节点，以减少树的深度。</li>
<li><strong>按秩合并（Union by Rank 或 Union by Size）</strong>：在合并两个集合时，将规模较小的集合连接到规模较大的集合下，避免形成深树。</li>
</ol>
<h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><ul>
<li>使用一个数组 <code>parent</code> 来表示每个元素的父节点，初始时每个元素都是自己的父节点。</li>
<li>使用一个数组 <code>rank</code> 来记录每棵树的高度，以便于在合并时按秩合并。</li>
</ul>
<h4 id="2-查找（Find）"><a href="#2-查找（Find）" class="headerlink" title="2. 查找（Find）"></a>2. 查找（Find）</h4><ul>
<li>查找时，通过递归找到根节点，并在路径上将所有节点直接连接到根节点（路径压缩）。</li>
</ul>
<h4 id="3-合并（Union）"><a href="#3-合并（Union）" class="headerlink" title="3. 合并（Union）"></a>3. 合并（Union）</h4><ul>
<li>合并时，通过比较两个集合的秩来决定将哪个集合连接到另一个集合上（按秩合并）。</li>
</ul>
<h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><strong><em>基础班</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 初始时，每个元素都是自己的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找根节点（无路径压缩）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合（无按秩合并）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个元素是否属于同一个集合</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  <span class="comment">// 父节点数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>优化版</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            parent[nums[i]] = nums[i];  <span class="comment">// 初始时，每个元素都是自己的父节点</span></span><br><span class="line">            rank[nums[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找根节点并进行路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);  <span class="comment">// 递归查找根节点并进行路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 按秩合并，将秩小的树合并到秩大的树下</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个元素是否属于同一个集合</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; parent;  <span class="comment">// 父节点数组</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rank;    <span class="comment">// 树的高度数组，用于优化合并操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设有10个元素，编号为0到9</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">    UnionFind <span class="built_in">uf</span>(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并一些集合</span></span><br><span class="line">    uf.<span class="built_in">unionSets</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    uf.<span class="built_in">unionSets</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    uf.<span class="built_in">unionSets</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    uf.<span class="built_in">unionSets</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    uf.<span class="built_in">unionSets</span>(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查连通性</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 和 7 是否连通: &quot;</span> &lt;&lt; (uf.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">7</span>) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4 和 6 是否连通: &quot;</span> &lt;&lt; (uf.<span class="built_in">isConnected</span>(<span class="number">4</span>, <span class="number">6</span>) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><ol>
<li><strong>类定义和初始化：</strong><ul>
<li><code>UnionFind(int n)</code>: 初始化大小为 <code>n</code> 的并查集，每个节点都是自己的父节点，初始秩为1。</li>
<li><code>parent</code> 数组用于存储每个节点的父节点。</li>
<li><code>rank</code> 数组用于存储树的高度，优化合并。</li>
</ul>
</li>
<li><strong>查找操作：</strong><ul>
<li><code>find(int x)</code>: 使用递归实现查找并进行路径压缩。路径压缩将每次查找的节点直接连接到根节点，显著减少后续查找操作的时间。</li>
</ul>
</li>
<li><strong>合并操作：</strong><ul>
<li><code>unionSets(int x, int y)</code>: 查找 <code>x</code> 和 <code>y</code> 的根节点，如果根节点不同则按秩合并。将高度较小的树连接到较大的树上，保证树的高度尽量保持较低。</li>
</ul>
</li>
<li><strong>检查连通性：</strong><ul>
<li><code>isConnected(int x, int y)</code>: 判断 <code>x</code> 和 <code>y</code> 是否属于同一个集合，通过比较它们的根节点是否相同来实现。</li>
</ul>
</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>查找（Find）</strong>：通过路径压缩，Find 操作的时间复杂度接近常数，可以表示为 <code>O(α(n))</code>，其中 <code>α(n)</code> 为反阿克曼函数，增长极为缓慢，几乎可以认为是常数。</li>
<li><strong>合并（Union）</strong>：按秩合并使得合并操作的时间复杂度也是接近常数，同样为 <code>O(α(n))</code>。</li>
</ul>
<p>因此，并查集适用于频繁的合并和查找操作场景，其操作复杂度非常低。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>网络连通性</strong>：检查网络中的节点是否连通。</li>
<li><strong>最小生成树算法</strong>：例如 Kruskal 算法，用于合并不同的边并检查环。</li>
<li><strong>动态连通性</strong>：处理一些动态添加、删除边的连通性问题。</li>
</ul>
<h3 id="3-相关例题"><a href="#3-相关例题" class="headerlink" title="3.相关例题"></a>3.相关例题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence?envType=study-plan-v2&amp;envId=top-100-liked">力扣128.最长连续序列</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0solving1.cn">LYT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0solving1.cn/2024/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86Union-Find-algorithm/">https://0solving1.cn/2024/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86Union-Find-algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://0solving1.cn" target="_blank">/0Solving1/</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a><a class="post-meta__tags" href="/tags/DataStruct/">DataStruct</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/27/%E5%8D%95%E8%B0%83%E6%A0%88-MonotoneStack/" title="单调栈-MonotoneStack"><img class="cover" src="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">单调栈-MonotoneStack</div></div><div class="info-2"><div class="info-item-1">单调栈引用链接： LeetCode算法通关手册-单调栈 Oi-wiki-单调栈 单调栈是一种数据结构，通常用于解决某些与数组或序列中的顺序相关的问题。它主要用于保持一个栈中的元素以单调递增或单调递减的顺序，因此被称为“单调栈”。单调栈特别适合解决需要在一个数组中寻找与每个元素有关的下一个更大（或更小）元素的问题，典型例子包括 “下一个更大元素”、”下一个更小元素” 等。  何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。 为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。  过程 插入 将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 例如，栈中自顶向下的元素为 。  插入元素  时为了保证单调性需要依次弹出元素 ，操作后栈变为 。  用伪代码描述如下： 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x   ...</div></div></div></a><a class="pagination-related" href="/2024/11/26/HexoWriteGuide/" title="HexoWriteGuide"><img class="cover" src="https://s2.loli.net/2024/11/26/N52prawjPAnIh6t.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HexoWriteGuide</div></div><div class="info-2"><div class="info-item-1"> hexo官方文档 butterfly帮助文档 butterfly官方文档 Hexo介绍Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架，常被用来搭建个人博客或技术博客。以下是对 Hexo 的简单介绍：  核心特点  静态站点生成： Hexo 可以将 Markdown 文件转换为静态的 HTML 页面，这些页面可以直接部署到静态文件托管服务（如 GitHub Pages、Netlify）。 速度快： Hexo 使用 Node.js 提供高效性能，支持快速生成成千上万篇文章的静态文件。 支持 Markdown： 使用简单且流行的 Markdown 语法撰写文章，提升写作效率。 主题丰富： Hexo 社区提供了大量主题，可以通过配置文件快速切换，满足不同用户的个性化需求。 插件生态： Hexo 拥有丰富的插件库，可扩展功能如 SEO 优化、RSS 支持、站点地图生成等。 支持多种部署方式： 内置一键部署到 GitHub Pages、GitLab Pages 或其他静态文件托管服务。    Hexo 的基本工作流程  安装 Hexo： 使用 npm 安装...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/29/Cplus-toJava-For-algorithmPractice/" title="C++toJava,For algorithmPractice"><img class="cover" src="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">C++toJava,For algorithmPractice</div></div><div class="info-2"><div class="info-item-1">C++刷题者快速入门Java指南引言本文旨在帮助有C++刷题经验的程序员快速适应Java编程环境,尤其是在Leetcode等算法编程网站上从事题目练习。文章将对比C++和Java在基本语法、数据结构实现等方面的异同,帮助读者尽快掌握Java刷题技巧。 基本语法对比变量声明 C++可以使用auto关键字进行类型推导,而Java需要显式声明变量类型。 Java变量声明时可以直接初始化,如int x = 1;C++须分开声明与定义。  输入输出 C++使用cin/cout进行标准输入输出,Java则使用System.in/System.out。 Java输入输出操作需要显式抛出异常,而C++无此要求。  字符串 Java内置String类,C++使用string。 Java字符串不可变,C++字符串可变。 Java字符串重载+运算符以实现拼接,C++需调用成员函数。  常见数据结构实现对比Vector / ArrayList C++: #include &lt;vector&gt; Java: import...</div></div></div></a><a class="pagination-related" href="/2024/11/29/SortAlgorithm%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="SortAlgorithm排序算法"><img class="cover" src="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">SortAlgorithm排序算法</div></div><div class="info-2"><div class="info-item-1">十大经典排序算法介绍与实现(Java/C++)引言排序算法是计算机科学与工程中最基础也最重要的算法之一。一个优秀的程序员必须深刻理解各种排序算法的原理、实现、优劣与应用场景。本文将详细介绍十种经典排序算法,并给出Java与C++的代码实现,旨在为读者全面梳理排序算法,夯实算法基本功。 1. 冒泡排序(Bubble Sort)1.1 算法原理冒泡排序重复遍历要排序的数列,每次比较两个元素,如果顺序错误就把它们交换过来。遍历数列的工作重复地进行,直到没有再需要交换,也就是说该数列已经排序完成。 1.2 Java实现123456789101112public void bubbleSort(int[] arr) &#123;    int n = arr.length;    for (int i = 0; i &lt; n-1; i++) &#123;        for (int j = 0; j &lt; n-i-1; j++) &#123;            if (arr[j] &gt; arr[j+1]) &#123;                int temp...</div></div></div></a><a class="pagination-related" href="/2024/11/29/StrangeInterviewQuestion%E5%A5%87%E6%80%AA%E9%9D%A2%E8%AF%95%E9%A2%98/" title="StrangeInterviewQuestion"><img class="cover" src="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">StrangeInterviewQuestion</div></div><div class="info-2"><div class="info-item-1">实现一个随机算法，要求每次返回1-100中的一个数，每次都不重复，每个数返回的几率均等，并且每次只能使用一次random函数。这是一个非常好的面试题。以下是我的解答： 实现思路：  初始化一个大小为100的数组，用于存储1-100的数字。 使用Fisher-Yates洗牌算法对数组进行随机打乱。该算法能够保证每个数字被等概率地放置在任意位置。 维护一个指针，初始指向数组的第一个元素。每次调用函数时，返回指针所指的元素，并将指针向后移动一位。 当指针移动到数组末尾时，重新对数组进行洗牌，并将指针重置为数组起始位置。  具体实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;algorithm&gt;class RandomNumber &#123;private:   ...</div></div></div></a><a class="pagination-related" href="/2024/11/27/%E5%8D%95%E8%B0%83%E6%A0%88-MonotoneStack/" title="单调栈-MonotoneStack"><img class="cover" src="https://s2.loli.net/2024/11/25/Mq4PjTgDrbn9vws.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-27</div><div class="info-item-2">单调栈-MonotoneStack</div></div><div class="info-2"><div class="info-item-1">单调栈引用链接： LeetCode算法通关手册-单调栈 Oi-wiki-单调栈 单调栈是一种数据结构，通常用于解决某些与数组或序列中的顺序相关的问题。它主要用于保持一个栈中的元素以单调递增或单调递减的顺序，因此被称为“单调栈”。单调栈特别适合解决需要在一个数组中寻找与每个元素有关的下一个更大（或更小）元素的问题，典型例子包括 “下一个更大元素”、”下一个更小元素” 等。  何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。 为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。  过程 插入 将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 例如，栈中自顶向下的元素为 。  插入元素  时为了保证单调性需要依次弹出元素 ，操作后栈变为 。  用伪代码描述如下： 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.并查集的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">优化策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">2.实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1. 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%EF%BC%88Find%EF%BC%89"><span class="toc-text">2. 查找（Find）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%88%E5%B9%B6%EF%BC%88Union%EF%BC%89"><span class="toc-text">3. 合并（Union）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">C++代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98"><span class="toc-text">3.相关例题</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.loli.net/2024/11/25/wTHFUo8B4IqvzL2.jpg);"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp-info"><br/><img src="https://s2.loli.net/2024/12/04/gC27Mc8uHTIlqWS.png" alt="备案图标"/><a href="http://www.beian.miit.gov.cn/" style="color:#f72b07" target="_blank">湘ICP备2024094835号</a></div><div class="footer_custom_text">To Make Pendulum-Summon Great Again.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script></div></body></html>